name: Auto Review & Merge

on:
  # Run when PRs are ready for review or updated
  pull_request:
    types: [opened, synchronize, ready_for_review]
  # Run when PR is labeled ready-to-merge
  pull_request_target:
    types: [labeled]
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to validate and merge'
        required: false
        type: number

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  validate:
    runs-on: ubuntu-latest
    # Only run on non-WIP, non-draft PRs or manual trigger
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request_target' && github.event.label.name == 'ready-to-merge') ||
      (github.event_name == 'pull_request' && !github.event.pull_request.draft && !contains(github.event.pull_request.title, '[WIP]'))
    
    outputs:
      validation_passed: ${{ steps.validate.outputs.passed }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    
    steps:
      - name: Get PR number
        id: get-pr
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ inputs.pr_number }}" ]; then
            echo "pr_number=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request_target" ]; then
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
      
      - name: Set up Python (for GDScript validation)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install gdtoolkit for GDScript linting
        run: pip install gdtoolkit
      
      - name: Validate Godot Project
        id: validate
        run: |
          echo "üîç Validating Godot project integrity..."
          echo ""
          ERRORS=0
          WARNINGS=0
          
          # Check 1: project.godot exists
          echo "üìÅ Checking project.godot..."
          if [ -f "project.godot" ]; then
            echo "   ‚úÖ project.godot found"
          else
            echo "   ‚ùå project.godot not found!"
            ERRORS=$((ERRORS + 1))
          fi
          echo ""
          
          # Check 2: Validate GDScript syntax with gdlint
          echo "üìù Checking GDScript syntax..."
          GDSCRIPT_FILES=$(find . -name "*.gd" -type f 2>/dev/null | head -100)
          SCRIPT_ERRORS=0
          
          for file in $GDSCRIPT_FILES; do
            # Use gdparse for syntax checking (less strict than gdlint)
            if ! gdparse "$file" > /dev/null 2>&1; then
              echo "   ‚ùå Syntax error in: $file"
              SCRIPT_ERRORS=$((SCRIPT_ERRORS + 1))
            fi
          done
          
          if [ $SCRIPT_ERRORS -eq 0 ]; then
            echo "   ‚úÖ All GDScript files have valid syntax"
          else
            echo "   ‚ùå Found $SCRIPT_ERRORS files with syntax errors"
            ERRORS=$((ERRORS + SCRIPT_ERRORS))
          fi
          echo ""
          
          # Check 3: Validate scene files exist and are not corrupted
          echo "üé¨ Checking scene files (.tscn)..."
          SCENE_FILES=$(find . -name "*.tscn" -type f 2>/dev/null)
          SCENE_ERRORS=0
          
          for file in $SCENE_FILES; do
            # Basic check: file should contain [gd_scene]
            if ! grep -q "\[gd_scene" "$file" 2>/dev/null; then
              echo "   ‚ùå Invalid scene file: $file"
              SCENE_ERRORS=$((SCENE_ERRORS + 1))
            fi
          done
          
          if [ $SCENE_ERRORS -eq 0 ]; then
            echo "   ‚úÖ All scene files appear valid"
          else
            echo "   ‚ùå Found $SCENE_ERRORS invalid scene files"
            ERRORS=$((ERRORS + SCENE_ERRORS))
          fi
          echo ""
          
          # Check 4: Validate resource files
          echo "üì¶ Checking resource files (.tres)..."
          RESOURCE_FILES=$(find . -name "*.tres" -type f 2>/dev/null)
          RESOURCE_ERRORS=0
          
          for file in $RESOURCE_FILES; do
            # Basic check: file should contain [gd_resource] or [ext_resource]
            if ! grep -qE "\[(gd_resource|ext_resource)" "$file" 2>/dev/null; then
              echo "   ‚ö†Ô∏è Possibly invalid resource: $file"
              WARNINGS=$((WARNINGS + 1))
            fi
          done
          
          if [ $RESOURCE_ERRORS -eq 0 ]; then
            echo "   ‚úÖ Resource files appear valid"
          fi
          echo ""
          
          # Check 5: No merge conflict markers
          echo "üîÄ Checking for merge conflict markers..."
          CONFLICT_FILES=$(grep -rl "^<<<<<<< " --include="*.gd" --include="*.tscn" --include="*.tres" . 2>/dev/null || true)
          
          if [ -z "$CONFLICT_FILES" ]; then
            echo "   ‚úÖ No merge conflict markers found"
          else
            echo "   ‚ùå Merge conflict markers found in:"
            echo "$CONFLICT_FILES" | while read f; do echo "      - $f"; done
            ERRORS=$((ERRORS + 1))
          fi
          echo ""
          
          # Check 6: Required files exist
          echo "üìã Checking required project files..."
          REQUIRED_FILES=("project.godot" "README.md")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "   ‚úÖ $file exists"
            else
              echo "   ‚ö†Ô∏è $file not found (warning)"
              WARNINGS=$((WARNINGS + 1))
            fi
          done
          echo ""
          
          # Summary
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä VALIDATION SUMMARY"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "   Errors:   $ERRORS"
          echo "   Warnings: $WARNINGS"
          echo ""
          
          if [ $ERRORS -eq 0 ]; then
            echo "‚úÖ VALIDATION PASSED - Project integrity verified!"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå VALIDATION FAILED - $ERRORS errors found"
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  auto-merge:
    needs: validate
    runs-on: ubuntu-latest
    if: needs.validate.outputs.validation_passed == 'true'
    
    steps:
      - name: Auto-merge PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = ${{ needs.validate.outputs.pr_number || github.event.pull_request.number }};
            
            console.log(`\nüîÑ Processing PR #${prNumber} for auto-merge...\n`);
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNumber
            });
            
            // Check if PR is mergeable
            if (pr.draft) {
              console.log('‚è∏Ô∏è PR is still a draft - skipping merge');
              return;
            }
            
            if (pr.title.includes('[WIP]')) {
              console.log('‚è∏Ô∏è PR is marked as WIP - skipping merge');
              return;
            }
            
            if (pr.mergeable === false) {
              console.log('‚ùå PR has merge conflicts - cannot merge');
              
              // Add comment about conflicts
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: '‚ö†Ô∏è **Auto-merge blocked**: This PR has merge conflicts. Please resolve them and try again.'
              });
              return;
            }
            
            if (pr.mergeable_state === 'blocked') {
              console.log('‚è∏Ô∏è PR is blocked by branch protection rules');
              return;
            }
            
            // Check if already merged
            if (pr.merged) {
              console.log('‚ÑπÔ∏è PR is already merged');
              return;
            }
            
            // All checks passed - merge!
            console.log('‚úÖ All validations passed - proceeding with merge...');
            
            try {
              const mergeResult = await github.rest.pulls.merge({
                owner, repo, pull_number: prNumber,
                commit_title: `${pr.title} (#${prNumber})`,
                commit_message: `Auto-merged by validation workflow\n\nValidation checks passed:\n- GDScript syntax: ‚úÖ\n- Scene files: ‚úÖ\n- No merge conflicts: ‚úÖ`,
                merge_method: 'squash'
              });
              
              console.log(`\nüéâ Successfully merged PR #${prNumber}!`);
              
              // Add merged label
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: prNumber,
                  labels: ['merged', 'auto-merged']
                });
              } catch (e) {
                // Create labels if they don't exist
                for (const label of ['merged', 'auto-merged']) {
                  try {
                    await github.rest.issues.createLabel({
                      owner, repo, name: label,
                      color: label === 'merged' ? '6f42c1' : '8250df',
                      description: label === 'merged' ? 'PR has been merged' : 'PR was auto-merged by workflow'
                    });
                    await github.rest.issues.addLabels({
                      owner, repo, issue_number: prNumber, labels: [label]
                    });
                  } catch (e2) { /* ignore */ }
                }
              }
              
              // Post success comment
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `üéâ **Auto-merged successfully!**\n\nThis PR passed all validation checks and was automatically merged.\n\n**Checks passed:**\n- ‚úÖ GDScript syntax validation\n- ‚úÖ Scene file integrity\n- ‚úÖ Resource file validation\n- ‚úÖ No merge conflict markers\n- ‚úÖ Required files present`
              });
              
            } catch (mergeError) {
              console.log(`‚ùå Merge failed: ${mergeError.message}`);
              
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `‚ö†Ô∏è **Auto-merge failed**\n\nError: ${mergeError.message}\n\nPlease review and merge manually.`
              });
            }

  # Track merged PRs and add labels
  label-merged:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    steps:
      - name: Add merged label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            
            // Ensure 'merged' label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: 'merged' });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner, repo, name: 'merged',
                  color: '6f42c1',
                  description: 'PR has been merged'
                });
              }
            }
            
            // Add label
            await github.rest.issues.addLabels({
              owner, repo, issue_number: prNumber, labels: ['merged']
            });
            
            console.log(`‚úÖ Added 'merged' label to PR #${prNumber}`);
